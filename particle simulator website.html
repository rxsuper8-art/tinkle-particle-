<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Particle Physics Engine</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #0f172a; color: #e2e8f0; font-family: ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif; }
        #canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }
        
        /* HARDWARE OPTIMIZATION: Surrender touch compositor to JS */
        #sim-canvas { touch-action: none; width: 100%; height: 100%; display: block; }
        
        #ui-panel { position: absolute; top: 1rem; right: 1rem; z-index: 10; width: 340px; max-height: calc(100vh - 2rem); overflow-y: auto; background: rgba(30, 41, 59, 0.85); backdrop-filter: blur(12px); border: 1px solid rgba(255, 255, 255, 0.1); border-radius: 0.75rem; padding: 1.5rem; box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5); }
        #ui-panel::-webkit-scrollbar { width: 6px; }
        #ui-panel::-webkit-scrollbar-track { background: transparent; }
        #ui-panel::-webkit-scrollbar-thumb { background: rgba(255, 255, 255, 0.2); border-radius: 3px; }
        
        .control-group { margin-bottom: 1rem; }
        .control-group label { display: flex; justify-content: space-between; font-size: 0.875rem; font-weight: 500; margin-bottom: 0.25rem; color: #cbd5e1; }
        input[type=range] { -webkit-appearance: none; width: 100%; background: transparent; }
        input[type=range]::-webkit-slider-thumb { -webkit-appearance: none; height: 16px; width: 16px; border-radius: 50%; background: #3b82f6; cursor: pointer; margin-top: -6px; box-shadow: 0 0 10px rgba(59, 130, 246, 0.5); }
        input[type=range]::-webkit-slider-runnable-track { width: 100%; height: 4px; cursor: pointer; background: #334155; border-radius: 2px; }
        select, button { width: 100%; background: #0f172a; border: 1px solid #334155; color: white; padding: 0.5rem; border-radius: 0.375rem; outline: none; transition: all 0.2s; }
        select:focus, button:focus { border-color: #3b82f6; box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.2); }
        button:hover { background: #1e293b; cursor: pointer; }
        .btn-primary { background: #2563eb; border-color: #2563eb; }
        .btn-primary:hover { background: #1d4ed8; border-color: #1d4ed8; }
        .btn-danger { background: #e11d48; border-color: #e11d48; }
        .btn-danger:hover { background: #be123c; border-color: #be123c; }
        
        /* Stats Display */
        #stats { position: absolute; top: 1rem; left: 1rem; z-index: 10; background: rgba(15, 23, 42, 0.8); backdrop-filter: blur(4px); padding: 0.5rem 1rem; border-radius: 0.5rem; font-family: monospace; font-size: 0.875rem; border: 1px solid rgba(255,255,255,0.1); pointer-events: none; }
        
        /* UI Panel Dopamine Transitions */
        #ui-panel { transition: transform 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275); } /* Spring physics ease */
        #ui-panel.collapsed { transform: translateX(120%); }
        
        /* STRICT BOUNDING BOX FOR ICON */
        #btn-toggle-ui { 
            position: absolute; top: 1rem; right: 1rem; z-index: 20; 
            background: rgba(30, 41, 59, 0.9); backdrop-filter: blur(8px); 
            border: 1px solid rgba(255, 255, 255, 0.1); color: white; 
            width: 36px; height: 36px; /* Explicit tight dimensions */
            display: flex; align-items: center; justify-content: center; /* Force center alignment */
            font-size: 1.1rem; /* Controlled glyph size */
            border-radius: 0.5rem; cursor: pointer; transition: all 0.2s; 
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.5); 
        }
        #btn-toggle-ui:hover { background: rgba(59, 130, 246, 0.8); transform: scale(1.05); }

        /* RESPONSIVE DESIGN: Mobile Device Architecture */
        @media (max-width: 768px) {
            #ui-panel {
                width: calc(100% - 2rem);
                top: auto;
                bottom: 1rem;
                max-height: 60vh;
            }
            /* Change collapse animation axis for bottom sheet */
            #ui-panel.collapsed { transform: translateY(120%); }
            
            #btn-toggle-ui {
                top: auto;
                bottom: 1rem;
                right: 1rem;
            }
            #stats {
                font-size: 0.75rem;
                padding: 0.25rem 0.5rem;
            }
        }
    </style>
</head>
<body>

    <button id="btn-toggle-ui" title="Toggle Settings">‚öôÔ∏è</button>

    <div id="stats">
        <div>FPS: <span id="fps-counter" class="text-blue-400">0</span></div>
        <div>Particles: <span id="particle-counter" class="text-green-400">0</span></div>
    </div>

    <div id="canvas-container">
        <canvas id="sim-canvas"></canvas>
    </div>

    <div id="ui-panel">
        <h1 class="text-xl font-bold mb-4 text-white border-b border-slate-700 pb-2">Physics Parameters</h1>
        
        <div class="control-group">
            <label><span>Gravity (Y-Axis)</span> <span id="val-gravityY">0</span></label>
            <input type="range" id="gravityY" min="-0.5" max="0.5" step="0.01" value="0">
        </div>

        <div class="control-group">
            <label><span>Restitution (Bounciness)</span> <span id="val-restitution">0.9</span></label>
            <input type="range" id="restitution" min="0" max="1.5" step="0.01" value="0.9">
        </div>

        <div class="control-group">
            <label><span>Friction (Air Drag)</span> <span id="val-friction">0.99</span></label>
            <input type="range" id="friction" min="0.8" max="1" step="0.001" value="0.99">
        </div>

        <div class="control-group">
            <label><span>Electro-Magnetic Force</span> <span id="val-electroStrength">15</span></label>
            <input type="range" id="electroStrength" min="0" max="50" step="1" value="15">
            <p class="text-xs text-slate-500 mt-1">Coulomb's Law: Opposite colors attract, similar colors repel.</p>
        </div>

        <div class="control-group">
            <label><span>Connection Distance</span> <span id="val-connectDist">150</span></label>
            <input type="range" id="connectDist" min="0" max="300" step="10" value="150">
        </div>

        <div class="control-group">
            <label><span>Trail Length (Alpha)</span> <span id="val-trail">0.2</span></label>
            <input type="range" id="trail" min="0.01" max="1" step="0.01" value="0.2">
        </div>

        <div class="control-group">
            <label><span>Mouse Interaction</span></label>
            <select id="mouseMode" class="mb-2">
                <option value="repel" selected>Repulse (Anti-Gravity)</option>
                <option value="attract">Attract (Black Hole)</option>
                <option value="spawn">Spawn Continuous</option>
                <option value="none">None</option>
            </select>
            <input type="range" id="mouseStrength" min="0.1" max="5" step="0.1" value="2">
        </div>

        <div class="control-group">
            <label><span>Spawn Shape</span></label>
            <select id="spawnShape">
                <option value="mixed" selected>Mixed (Random)</option>
                <option value="circle">Circle</option>
                <option value="square">Square</option>
                <option value="triangle">Triangle</option>
                <option value="hexagon">Hexagon</option>
                <option value="star">Star</option>
            </select>
        </div>

        <div class="grid grid-cols-2 gap-2 mt-4">
             <button id="btn-toggle-collisions" class="bg-slate-700 hover:bg-slate-600 text-white p-2 rounded text-sm transition-all border border-slate-600">Collisions: ON</button>
             <button id="btn-toggle-glow" class="bg-cyan-900/80 hover:bg-cyan-700 text-cyan-200 p-2 rounded text-sm transition-all border border-cyan-500 shadow-[0_0_15px_rgba(6,182,212,0.5)]">Glow: ON</button>
             <button id="btn-toggle-electro" class="bg-indigo-900/80 hover:bg-indigo-700 text-indigo-200 p-2 rounded text-sm transition-all border border-indigo-500 col-span-2">Electromagnetism: ON</button>
             <button id="btn-toggle-audio" class="col-span-2 bg-amber-600/80 hover:bg-amber-500 text-amber-100 p-2 rounded text-sm transition-all border border-amber-400 shadow-[0_0_15px_rgba(245,158,11,0.4)]">Audio Synth: ON</button>
        </div>

        <div class="control-group flex gap-2 mt-4">
            <button id="btn-burst" class="btn-primary flex-1">Burst (+50)</button>
            <button id="btn-clear" class="btn-danger flex-1">Clear All</button>
        </div>

        <div class="mt-6 border-t border-slate-700 pt-4">
            <h2 class="text-lg font-bold mb-2 text-white">‚ú® AI Lab Assistant</h2>
            <p class="text-xs text-slate-400 mb-2">Describe a physics scenario, and the AI will automatically configure the engine parameters.</p>
            <textarea id="ai-prompt" rows="2" class="w-full bg-slate-800 border border-slate-600 rounded p-2 text-sm text-white mb-2" placeholder="e.g., 'Zero-gravity bouncy environment with glowing stars'"></textarea>
            <button id="btn-ai-generate" class="w-full bg-gradient-to-r from-purple-600 to-blue-600 hover:from-purple-500 hover:to-blue-500 text-white font-bold py-2 px-4 rounded transition-all shadow-[0_0_15px_rgba(139,92,246,0.3)]">
                ‚ú® Generate Scenario
            </button>
            <div id="ai-response" class="mt-3 text-sm text-cyan-300 hidden font-medium"></div>
        </div>

        <div class="mt-6 border-t border-slate-700 pt-4 mb-4">
            <h2 class="text-lg font-bold mb-2 text-white">üéôÔ∏è Live AI Commentator</h2>
            <p class="text-xs text-slate-400 mb-2">The AI will read live telemetry data and use Text-to-Speech to announce its scientific findings.</p>
            <button id="btn-ai-analyze" class="w-full bg-gradient-to-r from-emerald-600 to-teal-600 hover:from-emerald-500 hover:to-teal-500 text-white font-bold py-2 px-4 rounded transition-all shadow-[0_0_15px_rgba(16,185,129,0.3)]">
                ‚ú® Analyze & Announce State
            </button>
            <div id="ai-analyze-response" class="mt-3 text-sm text-emerald-300 hidden font-medium italic"></div>
        </div>
    </div>

    <script>
        /**
         * ADVANCED PARTICLE PHYSICS ENGINE
         * --------------------------------
         * Features Spatial Hashing for O(n log n) broad-phase collision detection,
         * Coulomb's Law electromagnetism, Procedural Web Audio Synthesis with Polyphony Limiting, 
         * Device Pixel Ratio (DPR) hardware scaling, and AI Integration.
         */

        const canvas = document.getElementById('sim-canvas');
        const ctx = canvas.getContext('2d', { alpha: false }); 
        
        const apiKey = ""; // Gemini API Key is provided by the environment
        
        let width, height;
        let particles = [];
        let particleIdCounter = 0;
        let lastTime = performance.now();
        let frames = 0;
        let fps = 0;

        // Dopamine Reward Entities
        let sparks = [];
        let shockwaves = [];
        
        const mouse = { x: -1000, y: -1000, isDown: false };

        // INITIAL SCIENTIFIC DEFAULTS (Self-Organizing Plasma State)
        const config = {
            gravity: { x: 0, y: 0 },
            restitution: 0.9,    
            friction: 0.99,      
            connectDist: 150,    
            trailAlpha: 0.2,     
            mouseMode: 'repel',  
            mouseStrength: 2.0,  
            spawnShape: 'mixed',
            collisionsEnabled: true,
            glowEnabled: true,
            electromagnetism: true,
            electroStrength: 15,
            audioEnabled: true
        };

        // Auto-collapse UI on mobile loads for immediate engagement
        if (window.innerWidth < 768) {
            document.getElementById('ui-panel').classList.add('collapsed');
        }

        // --- üîä PROCEDURAL AUDIO SYNTHESIZER WITH POLYPHONY LIMITING ---
        const AudioEngine = {
            ctx: null,
            masterGain: null,
            frameAudioCount: 0, 
            
            init() {
                if (this.ctx) return;
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                if (!AudioContext) return; 
                this.ctx = new AudioContext();
                this.masterGain = this.ctx.createGain();
                this.masterGain.gain.value = 0.15; 
                
                const compressor = this.ctx.createDynamicsCompressor();
                compressor.threshold.value = -10;
                compressor.knee.value = 10;
                compressor.ratio.value = 12;
                compressor.attack.value = 0;
                compressor.release.value = 0.25;

                this.masterGain.connect(compressor);
                compressor.connect(this.ctx.destination);
            },
            playCollision(velocity, mass, xPosition) {
                if (!config.audioEnabled || !this.ctx || this.ctx.state !== 'running') return;
                
                if (this.frameAudioCount >= 8) return; 
                if (!isFinite(velocity) || !isFinite(mass) || Math.abs(velocity) < 2.5) return; 
                
                this.frameAudioCount++;

                const panX = Math.max(-1, Math.min(1, (xPosition / width) * 2 - 1));
                const panner = this.ctx.createStereoPanner ? this.ctx.createStereoPanner() : this.ctx.createPanner();
                if (panner.pan) panner.pan.value = panX; 
                else panner.setPosition(panX, 0, 1 - Math.abs(panX)); 

                const osc1 = this.ctx.createOscillator(); 
                const osc2 = this.ctx.createOscillator(); 
                const osc3 = this.ctx.createOscillator(); 
                const gain = this.ctx.createGain();
                
                let baseFreq = 2000 + (300 - Math.min(mass, 300)) * 6; 
                baseFreq = Math.max(200, Math.min(baseFreq, 12000));

                osc1.type = 'sine'; 
                osc1.frequency.value = baseFreq;

                osc2.type = 'sine'; 
                osc2.frequency.value = baseFreq * 2.756; 

                osc3.type = 'triangle'; 
                osc3.frequency.value = baseFreq * 4.16;

                let amplitude = Math.min(1, Math.abs(velocity) * 0.04);
                if (!isFinite(amplitude) || amplitude < 0.01) amplitude = 0.01;
                
                gain.gain.setValueAtTime(0, this.ctx.currentTime);
                gain.gain.linearRampToValueAtTime(amplitude, this.ctx.currentTime + 0.002); 
                gain.gain.setTargetAtTime(0, this.ctx.currentTime + 0.002, 0.08); 

                osc1.connect(gain);
                osc2.connect(gain);
                osc3.connect(gain);
                gain.connect(panner);
                panner.connect(this.masterGain);

                osc1.start(); osc2.start(); osc3.start();
                osc1.stop(this.ctx.currentTime + 0.4); 
                osc2.stop(this.ctx.currentTime + 0.4); 
                osc3.stop(this.ctx.currentTime + 0.4);
            },
            playMouseCrackle(force, xPosition) {
                if (!config.audioEnabled || !this.ctx || this.ctx.state !== 'running') return;
                
                if (this.frameAudioCount >= 8) return;
                if (!isFinite(force) || Math.random() > 0.05) return; 
                
                this.frameAudioCount++;

                const panX = Math.max(-1, Math.min(1, (xPosition / width) * 2 - 1));
                const panner = this.ctx.createStereoPanner ? this.ctx.createStereoPanner() : this.ctx.createPanner();
                if (panner.pan) panner.pan.value = panX;
                else panner.setPosition(panX, 0, 1 - Math.abs(panX));

                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                
                osc.type = 'square'; 
                osc.frequency.setValueAtTime(3000 + Math.random() * 5000, this.ctx.currentTime);
                
                gain.gain.setValueAtTime(0, this.ctx.currentTime);
                gain.gain.linearRampToValueAtTime(Math.min(0.04, force * 0.02), this.ctx.currentTime + 0.01);
                gain.gain.setTargetAtTime(0, this.ctx.currentTime + 0.01, 0.02);

                osc.connect(gain);
                gain.connect(panner);
                panner.connect(this.masterGain);

                osc.start();
                osc.stop(this.ctx.currentTime + 0.06);
            },
            resume() {
                if (this.ctx && this.ctx.state === 'suspended') {
                    this.ctx.resume();
                }
            }
        };

        const unlockAudio = () => {
            AudioEngine.init();
            AudioEngine.resume();
            document.removeEventListener('click', unlockAudio);
            document.removeEventListener('keydown', unlockAudio);
            document.removeEventListener('touchstart', unlockAudio);
        };
        document.addEventListener('click', unlockAudio);
        document.addEventListener('keydown', unlockAudio);
        document.addEventListener('touchstart', unlockAudio);


        // UI Binding
        const bindUI = (id, key, isFloat = true, subKey = null) => {
            const el = document.getElementById(id);
            const valEl = document.getElementById(`val-${id}`);
            el.addEventListener('input', (e) => {
                const val = isFloat ? parseFloat(e.target.value) : e.target.value;
                if (valEl) valEl.innerText = val;
                if (subKey) config[key][subKey] = val;
                else config[key] = val;
            });
        };

        bindUI('gravityY', 'gravity', true, 'y');
        bindUI('restitution', 'restitution');
        bindUI('friction', 'friction');
        bindUI('connectDist', 'connectDist');
        bindUI('trail', 'trailAlpha');
        bindUI('mouseStrength', 'mouseStrength');
        bindUI('electroStrength', 'electroStrength');

        document.getElementById('mouseMode').addEventListener('change', (e) => config.mouseMode = e.target.value);
        document.getElementById('spawnShape').addEventListener('change', (e) => config.spawnShape = e.target.value);
        
        const bindToggle = (id, key, labels, activeClass, inactiveClass) => {
            const btn = document.getElementById(id);
            btn.addEventListener('click', () => {
                config[key] = !config[key];
                btn.innerText = labels[config[key] ? 0 : 1];
                btn.className = config[key] ? activeClass : inactiveClass;
            });
        };

        bindToggle('btn-toggle-collisions', 'collisionsEnabled', ['Collisions: ON', 'Collisions: OFF'], 
            'bg-slate-700 hover:bg-slate-600 text-white p-2 rounded text-sm transition-all border border-slate-600', 
            'bg-red-900/50 hover:bg-red-900/80 text-red-200 p-2 rounded text-sm transition-all border border-red-500');

        bindToggle('btn-toggle-glow', 'glowEnabled', ['Glow: ON', 'Glow: OFF'], 
            'bg-cyan-900/80 hover:bg-cyan-700 text-cyan-200 p-2 rounded text-sm transition-all border border-cyan-500 shadow-[0_0_15px_rgba(6,182,212,0.5)]', 
            'bg-slate-700 hover:bg-slate-600 text-white p-2 rounded text-sm transition-all border border-slate-600');

        bindToggle('btn-toggle-electro', 'electromagnetism', ['Electromagnetism: ON', 'Electromagnetism: OFF'], 
            'bg-indigo-900/80 hover:bg-indigo-700 text-indigo-200 p-2 rounded text-sm transition-all border border-indigo-500 col-span-2', 
            'bg-slate-700 hover:bg-slate-600 text-white p-2 rounded text-sm transition-all border border-slate-600 col-span-2');

        bindToggle('btn-toggle-audio', 'audioEnabled', ['Audio Synth: ON', 'Audio Synth: OFF'], 
            'col-span-2 bg-amber-600/80 hover:bg-amber-500 text-amber-100 p-2 rounded text-sm transition-all border border-amber-400 shadow-[0_0_15px_rgba(245,158,11,0.4)]', 
            'col-span-2 bg-slate-700 hover:bg-slate-600 text-white p-2 rounded text-sm transition-all border border-slate-600');

        document.getElementById('btn-burst').addEventListener('click', () => spawnParticles(50));
        document.getElementById('btn-clear').addEventListener('click', () => particles = []);

        function resize() {
            width = window.innerWidth;
            height = window.innerHeight;
            
            // HARDWARE OPTIMIZATION: Multi-sample anti-aliasing via Device Pixel Ratio
            const dpr = window.devicePixelRatio || 1;
            
            canvas.width = width * dpr;
            canvas.height = height * dpr;
            canvas.style.width = width + 'px';
            canvas.style.height = height + 'px';
            
            // Normalize coordinate system mapping physical LEDs to logical CSS bounds
            ctx.scale(dpr, dpr);
        }
        window.addEventListener('resize', resize);
        resize();

        // Interaction & Audio Resumption
        const handleInteraction = (x, y, isDown) => {
            mouse.x = x; mouse.y = y; mouse.isDown = isDown;
            if (isDown) {
                AudioEngine.init();
                AudioEngine.resume();
            }
        };

        window.addEventListener('mousemove', (e) => handleInteraction(e.clientX, e.clientY, mouse.isDown));
        window.addEventListener('mousedown', (e) => handleInteraction(e.clientX, e.clientY, true));
        window.addEventListener('mouseup', () => handleInteraction(mouse.x, mouse.y, false));
        window.addEventListener('mouseleave', () => handleInteraction(-1000, -1000, false));
        window.addEventListener('touchstart', (e) => handleInteraction(e.touches[0].clientX, e.touches[0].clientY, true));
        window.addEventListener('touchmove', (e) => handleInteraction(e.touches[0].clientX, e.touches[0].clientY, mouse.isDown));
        window.addEventListener('touchend', () => handleInteraction(-1000, -1000, false));

        // Colors dictate charges: Cool colors = negative, Warm colors = positive
        const colorData = [
            { hex: '#3b82f6', charge: -1 }, // Blue
            { hex: '#8b5cf6', charge: -1 }, // Purple
            { hex: '#06b6d4', charge: -1 }, // Cyan
            { hex: '#ec4899', charge: 1 },  // Pink
            { hex: '#f43f5e', charge: 1 },  // Rose
            { hex: '#10b981', charge: 1 }   // Emerald (Anomaly)
        ];

        class SpatialGrid {
            constructor(cellSize) {
                this.cellSize = cellSize;
                this.cells = new Map();
            }
            clear(newCellSize) {
                this.cellSize = newCellSize;
                this.cells.clear();
            }
            hash(x, y) {
                return ((x / this.cellSize) | 0) + ((y / this.cellSize) | 0) * 73856093;
            }
            insert(particle) {
                const key = this.hash(particle.x, particle.y);
                let cell = this.cells.get(key);
                if (!cell) {
                    cell = [];
                    this.cells.set(key, cell);
                }
                cell.push(particle);
            }
            getNearby(particle, outArray) {
                outArray.length = 0; 
                const cx = (particle.x / this.cellSize) | 0;
                const cy = (particle.y / this.cellSize) | 0;
                
                for (let i = -1; i <= 1; i++) {
                    for (let j = -1; j <= 1; j++) {
                        const key = (cx + i) + (cy + j) * 73856093;
                        const cell = this.cells.get(key);
                        if (cell) {
                            for(let k = 0; k < cell.length; k++) {
                                outArray.push(cell[k]);
                            }
                        }
                    }
                }
            }
        }
        
        const globalGrid = new SpatialGrid(100);
        const nearbyBuffer = [];
        const TWO_PI = Math.PI * 2; 

        class Particle {
            constructor(x, y) {
                this.id = particleIdCounter++;
                this.x = x;
                this.y = y;
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 5 + 1;
                this.vx = Math.cos(angle) * speed;
                this.vy = Math.sin(angle) * speed;
                
                this.radius = Math.random() * 6 + 3;
                this.mass = Math.PI * this.radius * this.radius; 
                
                const cData = colorData[Math.floor(Math.random() * colorData.length)];
                this.color = cData.hex;
                this.charge = cData.charge; 
                
                const shapes = ['circle', 'square', 'triangle', 'hexagon', 'star'];
                this.shape = config.spawnShape === 'mixed' ? shapes[Math.floor(Math.random() * shapes.length)] : config.spawnShape;
                
                this.rotation = Math.random() * Math.PI * 2;
                this.rotationSpeed = (Math.random() - 0.5) * 0.2;
            }

            applyForce(fx, fy) {
                this.vx += fx / this.mass;
                this.vy += fy / this.mass;
            }

            update() {
                this.vx += config.gravity.x;
                this.vy += config.gravity.y;

                if (mouse.x > -100 && mouse.y > -100) {
                    const dx = mouse.x - this.x;
                    const dy = mouse.y - this.y;
                    const distanceSq = dx * dx + dy * dy;
                    const distance = Math.sqrt(distanceSq);
                    
                    if (distance > 0 && distance < 200) {
                        const forceDirectionX = dx / distance;
                        const forceDirectionY = dy / distance;
                        const force = (200 - distance) / 200 * config.mouseStrength;

                        if (config.mouseMode === 'attract') {
                            this.vx += forceDirectionX * force;
                            this.vy += forceDirectionY * force;
                            AudioEngine.playMouseCrackle(force, this.x);
                        } else if (config.mouseMode === 'repel') {
                            this.vx -= forceDirectionX * force;
                            this.vy -= forceDirectionY * force;
                            AudioEngine.playMouseCrackle(force, this.x);
                        }
                    }
                }

                this.vx *= config.friction;
                this.vy *= config.friction;

                this.x += this.vx;
                this.y += this.vy;
                this.rotation += this.rotationSpeed;

                // Restitution and Boundaries
                if (this.x - this.radius < 0) { 
                    this.x = this.radius; 
                    this.vx *= -config.restitution; 
                    AudioEngine.playCollision(this.vx, this.mass, this.x);
                } 
                else if (this.x + this.radius > width) { 
                    this.x = width - this.radius; 
                    this.vx *= -config.restitution; 
                    AudioEngine.playCollision(this.vx, this.mass, this.x);
                }
                if (this.y - this.radius < 0) { 
                    this.y = this.radius; 
                    this.vy *= -config.restitution; 
                    AudioEngine.playCollision(this.vy, this.mass, this.x);
                } 
                else if (this.y + this.radius > height) { 
                    this.y = height - this.radius; 
                    this.vy *= -config.restitution;
                    this.vx *= 0.95; 
                    AudioEngine.playCollision(this.vy, this.mass, this.x);
                }
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);
                
                ctx.fillStyle = this.color;

                if (config.glowEnabled) {
                    const speedSq = this.vx*this.vx + this.vy*this.vy;
                    ctx.shadowBlur = Math.min(25, 5 + speedSq * 0.5); 
                    ctx.shadowColor = this.color;
                } else {
                    ctx.shadowBlur = 0; 
                }

                ctx.beginPath();
                switch (this.shape) {
                    case 'circle': 
                        ctx.arc(0, 0, this.radius, 0, TWO_PI); 
                        break;
                    case 'square': 
                        ctx.rect(-this.radius, -this.radius, this.radius * 2, this.radius * 2); 
                        break;
                    case 'triangle': 
                        ctx.moveTo(0, -this.radius); 
                        ctx.lineTo(this.radius, this.radius); 
                        ctx.lineTo(-this.radius, this.radius); 
                        break;
                    case 'hexagon': 
                        for (let i = 0; i < 6; i++) { 
                            const angle = (Math.PI / 3) * i; 
                            ctx.lineTo(Math.cos(angle) * this.radius, Math.sin(angle) * this.radius); 
                        } 
                        break;
                    case 'star': 
                        const spikes = 5; 
                        const outerRadius = this.radius; 
                        const innerRadius = this.radius / 2;
                        for (let i = 0; i < spikes * 2; i++) {
                            const radius = i % 2 === 0 ? outerRadius : innerRadius;
                            const angle = (Math.PI / spikes) * i;
                            ctx.lineTo(Math.cos(angle) * radius, Math.sin(angle) * radius);
                        } 
                        break;
                }
                
                ctx.closePath();
                ctx.fill();
                ctx.restore();
            }
        }

        class Spark {
            constructor(x, y, color) {
                this.x = x; this.y = y;
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 8 + 4;
                this.vx = Math.cos(angle) * speed;
                this.vy = Math.sin(angle) * speed;
                this.color = color;
                this.life = 1.0; 
                this.decay = Math.random() * 0.05 + 0.02;
                this.size = Math.random() * 3 + 1;
            }
            update() {
                this.x += this.vx; this.y += this.vy;
                this.vx *= 0.92; this.vy *= 0.92; 
                this.life -= this.decay;
            }
            draw() {
                ctx.globalCompositeOperation = 'lighter'; 
                ctx.fillStyle = this.color;
                ctx.globalAlpha = Math.max(0, this.life);
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, TWO_PI);
                ctx.fill();
                ctx.globalAlpha = 1.0;
                ctx.globalCompositeOperation = 'source-over';
            }
        }

        class Shockwave {
            constructor(x, y, color) {
                this.x = x; this.y = y;
                this.color = color;
                this.radius = 2;
                this.maxRadius = Math.random() * 40 + 20;
                this.life = 1.0;
            }
            update() {
                this.radius += (this.maxRadius - this.radius) * 0.2; 
                this.life -= 0.05;
            }
            draw() {
                ctx.strokeStyle = this.color;
                ctx.globalAlpha = Math.max(0, this.life * 0.5);
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, TWO_PI);
                ctx.stroke();
                ctx.globalAlpha = 1.0;
            }
        }

        function spawnParticles(count, x = width / 2, y = height / 4) {
            for (let i = 0; i < count; i++) particles.push(new Particle(x + (Math.random() - 0.5) * 40, y + (Math.random() - 0.5) * 40));
        }

        function resolveCollision(p1, p2, distSq, dx, dy) {
            const minDistance = p1.radius + p2.radius;
            if (distSq < minDistance * minDistance && distSq > 0) {
                const distance = Math.sqrt(distSq);
                const overlap = minDistance - distance;
                const nx = dx / distance;
                const ny = dy / distance;
                
                const totalMass = p1.mass + p2.mass;
                const m1Ratio = p2.mass / totalMass;
                const m2Ratio = p1.mass / totalMass;

                p1.x -= nx * overlap * m1Ratio;
                p1.y -= ny * overlap * m1Ratio;
                p2.x += nx * overlap * m2Ratio;
                p2.y += ny * overlap * m2Ratio;

                const rvx = p2.vx - p1.vx;
                const rvy = p2.vy - p1.vy;
                const velAlongNormal = rvx * nx + rvy * ny;

                if (velAlongNormal > 0) return;

                AudioEngine.playCollision(velAlongNormal, p1.mass, p1.x);

                if (Math.abs(velAlongNormal) > 3.5) {
                    shockwaves.push(new Shockwave(p1.x - nx * p1.radius, p1.y - ny * p1.radius, p1.color));
                    const sparkCount = Math.min(10, Math.floor(Math.abs(velAlongNormal)));
                    for(let k = 0; k < sparkCount; k++) {
                        sparks.push(new Spark(p1.x - nx * p1.radius, p1.y - ny * p1.radius, p1.color));
                    }
                }

                const e = config.restitution;
                let j = -(1 + e) * velAlongNormal;
                j /= (1 / p1.mass + 1 / p2.mass);

                const impulseX = j * nx;
                const impulseY = j * ny;

                p1.vx -= impulseX / p1.mass;
                p1.vy -= impulseY / p1.mass;
                p2.vx += impulseX / p2.mass;
                p2.vy += impulseY / p2.mass;
            }
        }

        function applyElectromagnetism(p1, p2, distSq, dx, dy) {
            const force = (p1.charge * p2.charge * config.electroStrength) / distSq;
            const distance = Math.sqrt(distSq);
            
            if (Math.abs(force) > 5) return; 

            const fx = (dx / distance) * force;
            const fy = (dy / distance) * force;
            
            p1.applyForce(-fx, -fy);
            p2.applyForce(fx, fy);
        }

        // UI Toggle Logic
        document.getElementById('btn-toggle-ui').addEventListener('click', () => {
            const panel = document.getElementById('ui-panel');
            panel.classList.toggle('collapsed');
        });

        function updateUIFromConfig() {
            document.getElementById('gravityY').value = config.gravity.y;
            document.getElementById('val-gravityY').innerText = Number(config.gravity.y).toFixed(2);
            document.getElementById('restitution').value = config.restitution;
            document.getElementById('val-restitution').innerText = Number(config.restitution).toFixed(2);
            document.getElementById('friction').value = config.friction;
            document.getElementById('val-friction').innerText = Number(config.friction).toFixed(3);
            document.getElementById('electroStrength').value = config.electroStrength;
            document.getElementById('val-electroStrength').innerText = config.electroStrength;
            document.getElementById('connectDist').value = config.connectDist;
            document.getElementById('val-connectDist').innerText = config.connectDist;
            document.getElementById('trail').value = config.trailAlpha;
            document.getElementById('val-trail').innerText = Number(config.trailAlpha).toFixed(2);
            document.getElementById('mouseStrength').value = config.mouseStrength;
            
            document.getElementById('mouseMode').value = config.mouseMode;
            document.getElementById('spawnShape').value = config.spawnShape;

            const colBtn = document.getElementById('btn-toggle-collisions');
            colBtn.innerText = config.collisionsEnabled ? 'Collisions: ON' : 'Collisions: OFF';
            colBtn.className = config.collisionsEnabled 
                ? 'bg-slate-700 hover:bg-slate-600 text-white p-2 rounded text-sm transition-all border border-slate-600' 
                : 'bg-red-900/50 hover:bg-red-900/80 text-red-200 p-2 rounded text-sm transition-all border border-red-500';

            const glowBtn = document.getElementById('btn-toggle-glow');
            glowBtn.innerText = config.glowEnabled ? 'Glow: ON' : 'Glow: OFF';
            glowBtn.className = config.glowEnabled 
                ? 'bg-cyan-900/80 hover:bg-cyan-700 text-cyan-200 p-2 rounded text-sm transition-all border border-cyan-500 shadow-[0_0_15px_rgba(6,182,212,0.5)]' 
                : 'bg-slate-700 hover:bg-slate-600 text-white p-2 rounded text-sm transition-all border border-slate-600';

            const electroBtn = document.getElementById('btn-toggle-electro');
            electroBtn.innerText = config.electromagnetism ? 'Electromagnetism: ON' : 'Electromagnetism: OFF';
            electroBtn.className = config.electromagnetism 
                ? 'bg-indigo-900/80 hover:bg-indigo-700 text-indigo-200 p-2 rounded text-sm transition-all border border-indigo-500 col-span-2' 
                : 'bg-slate-700 hover:bg-slate-600 text-white p-2 rounded text-sm transition-all border border-slate-600 col-span-2';
                
            const audioBtn = document.getElementById('btn-toggle-audio');
            audioBtn.innerText = config.audioEnabled ? 'Audio Synth: ON' : 'Audio Synth: OFF';
            audioBtn.className = config.audioEnabled 
                ? 'col-span-2 bg-amber-600/80 hover:bg-amber-500 text-amber-100 p-2 rounded text-sm transition-all border border-amber-400 shadow-[0_0_15px_rgba(245,158,11,0.4)]' 
                : 'col-span-2 bg-slate-700 hover:bg-slate-600 text-white p-2 rounded text-sm transition-all border border-slate-600';
        }

        async function fetchGeminiScenario(promptText) {
            const endpoint = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`;
            
            const systemPrompt = `You are an AI physics engine controller. The user will describe a desired visual/physics simulation scenario.
            Your job is to translate their request into specific physics engine parameters.
            Available shapes: mixed, circle, square, triangle, hexagon, star.
            Available mouseModes: repel, attract, spawn, none.
            Return ONLY a valid JSON object matching the requested schema.`;

            const schema = {
                type: "OBJECT",
                properties: {
                    gravity: { type: "OBJECT", properties: { x: { type: "NUMBER" }, y: { type: "NUMBER" } } },
                    restitution: { type: "NUMBER", description: "Bounciness 0.0 to 1.5" },
                    friction: { type: "NUMBER", description: "Air drag 0.8 to 1.0 (1.0 is no drag)" },
                    electroStrength: { type: "NUMBER", description: "0 to 50" },
                    connectDist: { type: "NUMBER", description: "Distance to draw lines between particles (0 to 300)" },
                    trailAlpha: { type: "NUMBER", description: "0.01 to 1.0 (lower is longer trails)" },
                    mouseMode: { type: "STRING" },
                    mouseStrength: { type: "NUMBER" },
                    spawnShape: { type: "STRING" },
                    collisionsEnabled: { type: "BOOLEAN" },
                    glowEnabled: { type: "BOOLEAN" },
                    electromagnetism: { type: "BOOLEAN" },
                    particleBurst: { type: "INTEGER", description: "Number of new particles to spawn (0 to 200)" },
                    clearExisting: { type: "BOOLEAN", description: "Should we delete all current particles?" },
                    aiExplanation: { type: "STRING", description: "A short, fun, 1-sentence explanation of the physics rules you just applied." }
                },
                required: ["aiExplanation"]
            };

            const payload = {
                contents: [{ parts: [{ text: promptText }] }],
                systemInstruction: { parts: [{ text: systemPrompt }] },
                generationConfig: {
                    responseMimeType: "application/json",
                    responseSchema: schema
                }
            };

            const maxRetries = 5;
            const delays = [1000, 2000, 4000, 8000, 16000];
            
            for (let i = 0; i < maxRetries; i++) {
                try {
                    const response = await fetch(endpoint, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });
                    
                    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                    
                    const data = await response.json();
                    return JSON.parse(data.candidates[0].content.parts[0].text);
                } catch (error) {
                    if (i === maxRetries - 1) throw error;
                    await new Promise(r => setTimeout(r, delays[i]));
                }
            }
        }

        document.getElementById('btn-ai-generate').addEventListener('click', async () => {
            const promptInput = document.getElementById('ai-prompt');
            const promptText = promptInput.value.trim();
            if (!promptText) return;

            const btn = document.getElementById('btn-ai-generate');
            const responseDiv = document.getElementById('ai-response');
            
            btn.innerHTML = '‚ú® Analyzing Physics...';
            btn.disabled = true;
            btn.classList.add('opacity-50', 'cursor-not-allowed');
            responseDiv.classList.add('hidden');
            responseDiv.classList.replace('text-red-400', 'text-cyan-300'); 

            try {
                const aiConfig = await fetchGeminiScenario(promptText);
                
                if (aiConfig.gravity !== undefined) {
                    if (aiConfig.gravity.x !== undefined) config.gravity.x = aiConfig.gravity.x;
                    if (aiConfig.gravity.y !== undefined) config.gravity.y = aiConfig.gravity.y;
                }
                const keys = ['restitution', 'friction', 'electroStrength', 'connectDist', 'trailAlpha', 'mouseMode', 'mouseStrength', 'spawnShape', 'collisionsEnabled', 'glowEnabled', 'electromagnetism'];
                keys.forEach(key => {
                    if (aiConfig[key] !== undefined) config[key] = aiConfig[key];
                });

                updateUIFromConfig();

                if (aiConfig.clearExisting) particles = [];
                if (aiConfig.particleBurst > 0) spawnParticles(aiConfig.particleBurst);

                responseDiv.innerText = `‚ú® AI: ${aiConfig.aiExplanation}`;
                responseDiv.classList.remove('hidden');
                
            } catch (err) {
                console.error(err);
                responseDiv.innerText = "‚ùå Failed to contact the AI Lab Assistant. (Check API Key / Rate Limits)";
                responseDiv.classList.remove('hidden');
                responseDiv.classList.replace('text-cyan-300', 'text-red-400');
            } finally {
                btn.innerHTML = '‚ú® Generate Scenario';
                btn.disabled = false;
                btn.classList.remove('opacity-50', 'cursor-not-allowed');
            }
        });

        // --- ‚ú® AI NARRATOR & TTS INTEGRATION ---
        
        function playAudioFromBase64PCM(base64Data, sampleRate) {
            const binaryString = window.atob(base64Data);
            const bytes = new Uint8Array(binaryString.length);
            for (let i = 0; i < binaryString.length; i++) {
                bytes[i] = binaryString.charCodeAt(i);
            }
            const pcmData = new Int16Array(bytes.buffer);

            const numChannels = 1;
            const bitsPerSample = 16;
            const byteRate = sampleRate * numChannels * (bitsPerSample / 8);
            const blockAlign = numChannels * (bitsPerSample / 8);
            const wavBuffer = new ArrayBuffer(44 + pcmData.length * 2);
            const view = new DataView(wavBuffer);

            const writeString = (view, offset, string) => {
                for (let i = 0; i < string.length; i++) view.setUint8(offset + i, string.charCodeAt(i));
            };

            writeString(view, 0, 'RIFF');
            view.setUint32(4, 36 + pcmData.length * 2, true);
            writeString(view, 8, 'WAVE');
            writeString(view, 12, 'fmt ');
            view.setUint32(16, 16, true);
            view.setUint16(20, 1, true);
            view.setUint16(22, numChannels, true);
            view.setUint32(24, sampleRate, true);
            view.setUint32(28, byteRate, true);
            view.setUint16(32, blockAlign, true);
            view.setUint16(34, bitsPerSample, true);
            writeString(view, 36, 'data');
            view.setUint32(40, pcmData.length * 2, true);

            let offset = 44;
            for (let i = 0; i < pcmData.length; i++) {
                view.setInt16(offset, pcmData[i], true);
                offset += 2;
            }

            const blob = new Blob([view], { type: 'audio/wav' });
            const url = URL.createObjectURL(blob);
            const audio = new Audio(url);
            audio.play();
        }

        async function speakTextWithGemini(text) {
            const endpoint = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-tts:generateContent?key=${apiKey}`;
            const payload = {
                contents: [{ parts: [{ text: "Scientist: " + text }] }],
                generationConfig: {
                    responseModalities: ["AUDIO"],
                    speechConfig: {
                        voiceConfig: { prebuiltVoiceConfig: { voiceName: "Fenrir" } }
                    }
                },
                model: "gemini-2.5-flash-preview-tts"
            };

            try {
                const response = await fetch(endpoint, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                
                if (!response.ok) throw new Error("TTS Request failed");
                const data = await response.json();
                const audioPart = data.candidates?.[0]?.content?.parts?.[0]?.inlineData;
                
                if (audioPart) {
                    const match = audioPart.mimeType.match(/rate=(\d+)/);
                    const sampleRate = match ? parseInt(match[1]) : 24000;
                    playAudioFromBase64PCM(audioPart.data, sampleRate);
                }
            } catch (err) {
                console.error("TTS Error:", err);
            }
        }

        document.getElementById('btn-ai-analyze').addEventListener('click', async () => {
            const btn = document.getElementById('btn-ai-analyze');
            const responseDiv = document.getElementById('ai-analyze-response');
            
            btn.innerHTML = 'üéôÔ∏è Analyzing Telemetry...';
            btn.disabled = true;
            btn.classList.add('opacity-50', 'cursor-not-allowed');
            responseDiv.classList.add('hidden');
            responseDiv.classList.replace('text-red-400', 'text-emerald-300');

            let totalSpeed = 0;
            particles.forEach(p => { totalSpeed += Math.sqrt(p.vx*p.vx + p.vy*p.vy); });
            const avgSpeed = particles.length > 0 ? (totalSpeed / particles.length).toFixed(2) : 0;
            
            let totalEnergy = 0;
            particles.forEach(p => { totalEnergy += 0.5 * p.mass * (p.vx*p.vx + p.vy*p.vy); });

            const stateDescription = `
            Particle Count: ${particles.length}
            Avg Speed: ${avgSpeed}
            Total Kinetic Energy: ${totalEnergy.toFixed(0)}
            Gravity Y: ${config.gravity.y}
            Bounciness: ${config.restitution}
            Friction: ${config.friction}
            Electromagnetism: ${config.electromagnetism ? 'ON' : 'OFF'}
            `;

            const systemPrompt = "You are a dramatic, slightly mad scientist observing a live physics experiment.";
            const userPrompt = `Analyze this live simulation telemetry and provide a 2-sentence dramatic observation of what this physical environment resembles in the real world or cosmos (e.g., 'This is behaving like a super-heated plasma state!' or 'The dampening field is causing absolute stagnation!'). Keep it under 40 words total.
            
            Telemetry:
            ${stateDescription}`;

            const payload = {
                contents: [{ parts: [{ text: userPrompt }] }],
                systemInstruction: { parts: [{ text: systemPrompt }] }
            };

            try {
                const endpoint = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`;
                const response = await fetch(endpoint, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                
                if (!response.ok) throw new Error("Analysis failed");
                const data = await response.json();
                const analysisText = data.candidates?.[0]?.content?.parts?.[0]?.text || "Fascinating data, but my sensors are offline!";
                
                responseDiv.innerText = `"${analysisText}"`;
                responseDiv.classList.remove('hidden');
                
                speakTextWithGemini(analysisText);

            } catch (err) {
                console.error(err);
                responseDiv.innerText = "‚ùå Telemetry analysis failed.";
                responseDiv.classList.remove('hidden');
                responseDiv.classList.replace('text-emerald-300', 'text-red-400');
            } finally {
                btn.innerHTML = '‚ú® Analyze & Announce State';
                btn.disabled = false;
                btn.classList.remove('opacity-50', 'cursor-not-allowed');
            }
        });

        function animate(now) {
            frames++;
            if (now - lastTime >= 1000) {
                fps = frames;
                frames = 0;
                lastTime = now;
                document.getElementById('fps-counter').innerText = fps;
                document.getElementById('particle-counter').innerText = particles.length;
            }
            
            AudioEngine.frameAudioCount = 0;

            if (mouse.isDown && config.mouseMode === 'spawn') particles.push(new Particle(mouse.x, mouse.y));

            ctx.fillStyle = `rgba(15, 23, 42, ${config.trailAlpha})`;
            ctx.fillRect(0, 0, width, height);

            for (let i = 0; i < particles.length; i++) {
                particles[i].update();
            }

            const cellSize = Math.max(40, config.connectDist);
            globalGrid.clear(cellSize);
            
            for (let i = 0; i < particles.length; i++) {
                globalGrid.insert(particles[i]);
            }

            const distSqMax = config.connectDist * config.connectDist;
            const lineBuckets = Array.from({length: 10}, () => []);

            for (let i = 0; i < particles.length; i++) {
                const p1 = particles[i];
                globalGrid.getNearby(p1, nearbyBuffer);

                for (let j = 0; j < nearbyBuffer.length; j++) {
                    const p2 = nearbyBuffer[j];
                    
                    if (p1.id < p2.id) {
                        const dx = p2.x - p1.x;
                        const dy = p2.y - p1.y;
                        const distSq = dx * dx + dy * dy;

                        if (config.electromagnetism && distSq > 4) { 
                            applyElectromagnetism(p1, p2, distSq, dx, dy);
                        }

                        if (config.collisionsEnabled) {
                            resolveCollision(p1, p2, distSq, dx, dy);
                        }

                        if (config.connectDist > 0 && distSq < distSqMax) {
                            const opacityIndex = Math.floor((1 - (distSq / distSqMax)) * 9);
                            lineBuckets[opacityIndex].push(p1.x, p1.y, p2.x, p2.y);
                        }
                    }
                }
            }

            ctx.lineWidth = 1;
            for (let b = 0; b < 10; b++) {
                if (lineBuckets[b].length === 0) continue;
                const opacity = (b + 1) * 0.05; 
                ctx.strokeStyle = `rgba(148, 163, 184, ${opacity})`;
                ctx.beginPath();
                for (let k = 0; k < lineBuckets[b].length; k += 4) {
                    ctx.moveTo(lineBuckets[b][k], lineBuckets[b][k+1]);
                    ctx.lineTo(lineBuckets[b][k+2], lineBuckets[b][k+3]);
                }
                ctx.stroke();
            }

            for (let i = 0; i < particles.length; i++) {
                particles[i].draw();
            }

            for (let i = sparks.length - 1; i >= 0; i--) {
                sparks[i].update();
                sparks[i].draw();
                if (sparks[i].life <= 0) sparks.splice(i, 1);
            }
            
            for (let i = shockwaves.length - 1; i >= 0; i--) {
                shockwaves[i].update();
                shockwaves[i].draw();
                if (shockwaves[i].life <= 0) shockwaves.splice(i, 1);
            }

            let aliveCount = 0;
            for (let i = 0; i < particles.length; i++) {
                let p = particles[i];
                if (p.x > -100 && p.x < width + 100 && p.y > -100 && p.y < height + 100) {
                    particles[aliveCount++] = p;
                }
            }
            particles.length = aliveCount; 

            requestAnimationFrame(animate);
        }

        spawnParticles(100);
        requestAnimationFrame(animate);

    </script>
</body>
</html>